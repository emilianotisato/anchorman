package screens

import (
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"

	"github.com/emilianohg/anchorman/internal/config"
	"github.com/emilianohg/anchorman/internal/models"
	"github.com/emilianohg/anchorman/internal/repository"
)

type reportsMode int

const (
	reportsModeSelectCompany reportsMode = iota
	reportsModeSelectRange
	reportsModePreview
	reportsModeGenerating
	reportsModeComplete
)

type dateRange int

const (
	rangeToday dateRange = iota
	rangeThisWeek
	rangeLastWeek
	rangeThisMonth
	rangeLast7Days
	rangeLast30Days
)

var rangeLabels = []string{
	"Today",
	"This Week",
	"Last Week",
	"This Month",
	"Last 7 Days",
	"Last 30 Days",
}

type Reports struct {
	db     *sql.DB
	cfg    *config.Config
	width  int
	height int

	companies       []repository.CompanyWithStats
	companyFilter   *int64
	companyCursor   int
	rangeCursor     int
	mode            reportsMode
	selectedRange   dateRange
	previewTasks    []models.Task
	generatedPath   string
	loading         bool
	err             error
	message         string
}

func NewReports(db *sql.DB, cfg *config.Config) *Reports {
	return &Reports{
		db:  db,
		cfg: cfg,
	}
}

func (r *Reports) SetSize(width, height int) {
	r.width = width
	r.height = height
}

func (r *Reports) SetCompanyFilter(companyID *int64) {
	r.companyFilter = companyID
}

type reportsDataMsg struct {
	companies []repository.CompanyWithStats
	err       error
}

type previewDataMsg struct {
	tasks []models.Task
	err   error
}

type generateCompleteMsg struct {
	path string
	err  error
}

func (r *Reports) Init() tea.Cmd {
	r.loading = true
	r.mode = reportsModeSelectCompany
	r.message = ""
	r.generatedPath = ""

	if r.companyFilter != nil {
		r.mode = reportsModeSelectRange
	}

	return r.loadData
}

func (r *Reports) loadData() tea.Msg {
	companyRepo := repository.NewCompanyRepo(r.db)
	companies, err := companyRepo.GetAllWithStats()
	return reportsDataMsg{companies: companies, err: err}
}

func (r *Reports) loadPreview() tea.Msg {
	if r.companyFilter == nil {
		return previewDataMsg{err: fmt.Errorf("no company selected")}
	}

	from, to := r.getDateRange()
	taskRepo := repository.NewTaskRepo(r.db)
	tasks, err := taskRepo.GetByCompanyAndDateRange(*r.companyFilter, from, to)
	return previewDataMsg{tasks: tasks, err: err}
}

func (r *Reports) generateReport() tea.Msg {
	if r.companyFilter == nil {
		return generateCompleteMsg{err: fmt.Errorf("no company selected")}
	}

	// Find company name
	var companyName string
	for _, c := range r.companies {
		if c.ID == *r.companyFilter {
			companyName = c.Name
			break
		}
	}

	from, to := r.getDateRange()
	taskRepo := repository.NewTaskRepo(r.db)
	tasks, err := taskRepo.GetByCompanyAndDateRange(*r.companyFilter, from, to)
	if err != nil {
		return generateCompleteMsg{err: err}
	}

	// Group tasks by project
	tasksByProject := make(map[string][]models.Task)
	for _, t := range tasks {
		tasksByProject[t.ProjectName] = append(tasksByProject[t.ProjectName], t)
	}

	// Generate markdown
	var md strings.Builder
	md.WriteString(fmt.Sprintf("# %s - Report\n\n", companyName))
	md.WriteString(fmt.Sprintf("**Period:** %s - %s\n", from.Format("January 02, 2006"), to.Format("January 02, 2006")))
	md.WriteString(fmt.Sprintf("**Generated:** %s\n\n", time.Now().Format("2006-01-02")))
	md.WriteString("---\n\n")

	for projectName, projectTasks := range tasksByProject {
		md.WriteString(fmt.Sprintf("## %s\n\n", projectName))
		for _, t := range projectTasks {
			md.WriteString(fmt.Sprintf("- %s\n", t.Description))
		}
		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
	md.WriteString("*Generated by Anchorman*\n")

	// Write file
	outputDir := r.cfg.ReportsOutput
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return generateCompleteMsg{err: fmt.Errorf("failed to create output directory: %w", err)}
	}

	slug := strings.ToLower(strings.ReplaceAll(companyName, " ", "-"))
	filename := fmt.Sprintf("%s_%s_to_%s.md",
		slug,
		from.Format("2006-01-02"),
		to.Format("2006-01-02"),
	)
	filepath := filepath.Join(outputDir, filename)

	if err := os.WriteFile(filepath, []byte(md.String()), 0644); err != nil {
		return generateCompleteMsg{err: fmt.Errorf("failed to write report: %w", err)}
	}

	return generateCompleteMsg{path: filepath}
}

func (r *Reports) getDateRange() (time.Time, time.Time) {
	now := time.Now()
	today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())

	switch r.selectedRange {
	case rangeToday:
		return today, today.Add(24*time.Hour - time.Second)
	case rangeThisWeek:
		weekday := int(today.Weekday())
		if weekday == 0 {
			weekday = 7
		}
		start := today.AddDate(0, 0, -weekday+1)
		return start, today.Add(24*time.Hour - time.Second)
	case rangeLastWeek:
		weekday := int(today.Weekday())
		if weekday == 0 {
			weekday = 7
		}
		end := today.AddDate(0, 0, -weekday)
		start := end.AddDate(0, 0, -6)
		return start, end.Add(24*time.Hour - time.Second)
	case rangeThisMonth:
		start := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
		return start, today.Add(24*time.Hour - time.Second)
	case rangeLast7Days:
		return today.AddDate(0, 0, -6), today.Add(24*time.Hour - time.Second)
	case rangeLast30Days:
		return today.AddDate(0, 0, -29), today.Add(24*time.Hour - time.Second)
	}
	return today, today
}

func (r *Reports) Update(msg tea.Msg) tea.Cmd {
	switch msg := msg.(type) {
	case reportsDataMsg:
		r.loading = false
		r.err = msg.err
		r.companies = msg.companies

		// If company filter is set, move to range selection
		if r.companyFilter != nil {
			for i, c := range r.companies {
				if c.ID == *r.companyFilter {
					r.companyCursor = i
					break
				}
			}
		}
		return nil

	case previewDataMsg:
		r.loading = false
		r.err = msg.err
		r.previewTasks = msg.tasks
		return nil

	case generateCompleteMsg:
		r.loading = false
		r.err = msg.err
		r.generatedPath = msg.path
		if msg.err == nil {
			r.mode = reportsModeComplete
		}
		return nil

	case RefreshMsg:
		return r.Init()

	case tea.KeyMsg:
		return r.handleKey(msg)
	}

	return nil
}

func (r *Reports) handleKey(msg tea.KeyMsg) tea.Cmd {
	switch r.mode {
	case reportsModeSelectCompany:
		return r.handleCompanyKey(msg)
	case reportsModeSelectRange:
		return r.handleRangeKey(msg)
	case reportsModePreview:
		return r.handlePreviewKey(msg)
	case reportsModeComplete:
		return r.handleCompleteKey(msg)
	}
	return nil
}

func (r *Reports) handleCompanyKey(msg tea.KeyMsg) tea.Cmd {
	switch msg.String() {
	case "up", "k":
		if r.companyCursor > 0 {
			r.companyCursor--
		}
	case "down", "j":
		if r.companyCursor < len(r.companies)-1 {
			r.companyCursor++
		}
	case "enter":
		if len(r.companies) > 0 {
			r.companyFilter = &r.companies[r.companyCursor].ID
			r.mode = reportsModeSelectRange
		}
	case "q", "esc":
		return Navigate("dashboard")
	}
	return nil
}

func (r *Reports) handleRangeKey(msg tea.KeyMsg) tea.Cmd {
	switch msg.String() {
	case "up", "k":
		if r.rangeCursor > 0 {
			r.rangeCursor--
		}
	case "down", "j":
		if r.rangeCursor < len(rangeLabels)-1 {
			r.rangeCursor++
		}
	case "enter":
		r.selectedRange = dateRange(r.rangeCursor)
		r.mode = reportsModePreview
		r.loading = true
		return r.loadPreview
	case "esc":
		r.mode = reportsModeSelectCompany
		r.companyFilter = nil
	case "q":
		return Navigate("dashboard")
	}
	return nil
}

func (r *Reports) handlePreviewKey(msg tea.KeyMsg) tea.Cmd {
	switch msg.String() {
	case "enter", "g":
		r.mode = reportsModeGenerating
		r.loading = true
		return r.generateReport
	case "esc":
		r.mode = reportsModeSelectRange
	case "q":
		return Navigate("dashboard")
	}
	return nil
}

func (r *Reports) handleCompleteKey(msg tea.KeyMsg) tea.Cmd {
	switch msg.String() {
	case "enter", "q", "esc":
		return Navigate("dashboard")
	}
	return nil
}

func (r *Reports) View() string {
	var b strings.Builder

	b.WriteString(TitleStyle.Render("GENERATE REPORT"))
	b.WriteString("\n\n")

	if r.loading {
		b.WriteString("Loading...\n")
		return b.String()
	}

	if r.err != nil {
		b.WriteString(ErrorStyle.Render(fmt.Sprintf("Error: %v", r.err)))
		b.WriteString("\n\n")
		r.err = nil
	}

	switch r.mode {
	case reportsModeSelectCompany:
		return r.viewSelectCompany(&b)
	case reportsModeSelectRange:
		return r.viewSelectRange(&b)
	case reportsModePreview:
		return r.viewPreview(&b)
	case reportsModeComplete:
		return r.viewComplete(&b)
	}

	return b.String()
}

func (r *Reports) viewSelectCompany(b *strings.Builder) string {
	b.WriteString("Select company:\n\n")

	if len(r.companies) == 0 {
		b.WriteString(DimStyle.Render("No companies. Create one first."))
		b.WriteString("\n\n")
	} else {
		for i, c := range r.companies {
			cursor := "  "
			style := NormalStyle
			if i == r.companyCursor {
				cursor = "> "
				style = SelectedStyle
			}
			b.WriteString(style.Render(fmt.Sprintf("%s%s (%d tasks)", cursor, c.Name, c.TaskCount)))
			b.WriteString("\n")
		}
	}

	b.WriteString("\n")
	b.WriteString(HelpStyle.Render("[enter] Select  [q] Back"))

	return b.String()
}

func (r *Reports) viewSelectRange(b *strings.Builder) string {
	// Show selected company
	for _, c := range r.companies {
		if c.ID == *r.companyFilter {
			b.WriteString(fmt.Sprintf("Company: %s\n\n", SelectedStyle.Render(c.Name)))
			break
		}
	}

	b.WriteString("Select date range:\n\n")

	for i, label := range rangeLabels {
		cursor := "  "
		style := NormalStyle
		if i == r.rangeCursor {
			cursor = "> "
			style = SelectedStyle
		}
		b.WriteString(style.Render(fmt.Sprintf("%s%s", cursor, label)))
		b.WriteString("\n")
	}

	b.WriteString("\n")
	b.WriteString(HelpStyle.Render("[enter] Select  [esc] Back  [q] Cancel"))

	return b.String()
}

func (r *Reports) viewPreview(b *strings.Builder) string {
	// Show selected company and range
	for _, c := range r.companies {
		if c.ID == *r.companyFilter {
			b.WriteString(fmt.Sprintf("Company: %s\n", SelectedStyle.Render(c.Name)))
			break
		}
	}
	from, to := r.getDateRange()
	b.WriteString(fmt.Sprintf("Period: %s - %s\n\n", from.Format("Jan 02"), to.Format("Jan 02, 2006")))

	if len(r.previewTasks) == 0 {
		b.WriteString(WarningStyle.Render("No tasks found for this period."))
		b.WriteString("\n")
		b.WriteString(DimStyle.Render("Process some commits first, or select a different date range."))
	} else {
		b.WriteString(fmt.Sprintf("Found %d tasks:\n\n", len(r.previewTasks)))

		// Group by project
		tasksByProject := make(map[string][]models.Task)
		for _, t := range r.previewTasks {
			tasksByProject[t.ProjectName] = append(tasksByProject[t.ProjectName], t)
		}

		for projectName, tasks := range tasksByProject {
			b.WriteString(SubtitleStyle.Render(projectName))
			b.WriteString("\n")
			for _, t := range tasks {
				b.WriteString(fmt.Sprintf("  - %s\n", t.Description))
			}
			b.WriteString("\n")
		}
	}

	b.WriteString("\n")
	if len(r.previewTasks) > 0 {
		b.WriteString(HelpStyle.Render("[g/enter] Generate  [esc] Back  [q] Cancel"))
	} else {
		b.WriteString(HelpStyle.Render("[esc] Back  [q] Cancel"))
	}

	return b.String()
}

func (r *Reports) viewComplete(b *strings.Builder) string {
	b.WriteString(SuccessStyle.Render("Report generated successfully!"))
	b.WriteString("\n\n")
	b.WriteString(fmt.Sprintf("Saved to:\n%s", r.generatedPath))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("[enter] Done"))

	return b.String()
}
